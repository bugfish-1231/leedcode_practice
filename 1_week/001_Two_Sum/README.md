### 📝 題目：[ 001 Two Sum ]

#### 🧠 解題思路
1. **暴力解法 (Brute Force)**
   - 思路：使用雙層迴圈。外層迴圈選定一個數字 nums[i]，內層迴圈把該數字後面的所有數字 nums[j] 都掃過一遍，檢查 nums[i] + nums[j] 是否等於 target
   - 時間複雜度：$O(n^2)$。因為兩個巢狀迴圈，當資料量到達數萬筆時會非常慢（可能導致 Time Limit Exceeded）
   - 空間複雜度：$O(1)$。只使用了常數級別的變數 i 與 j，沒有宣告額外的陣列或資料結構。
2. **最佳化解法 (Optimal Solution)**
   - 思路：利用 unordered_map (Hash Map) 來儲存 看過的數字及其索引，從而將時間複雜度降下來。核心概念是「尋找差值 (Complement)」。我們只要遍歷陣列一次，每看一個數字，就去查 Map 裡面有沒有「Target 減去當前數字」的結果。如果有，代表我們找到另一半了；如果沒有，就把當前數字存進 Map 給後面的數字配對。
   - 時間複雜度：$O(n)$。陣列只遍歷一次，且 C++ 中 unordered_map 的查詢時間平均為 $O(1)$。
   - 空間複雜度：$O(n)$。最壞的情況下（例如答案在陣列的最後兩個），我們需要把前面所有的數字都存進 Hash Map 中。這是標準的空間換取時間。

#### 💻 語言差異與踩坑紀錄
* **C++**：
  * std::unordered_map<int, int> 的應用：學會了在 C++ 中如何宣告並使用 Hash Map 來達成 $O(1)$ 的極速查詢。
  * 安全的查詢寫法：學會使用 map.find(key) != map.end() 來判斷 Key 是否存在。如果直接用 map[key] 來查，當 Key 不存在時，C++ 會自動幫你建一個預設值為 0 的 Key，這會引發難以察覺的 Bug。
  * 傳參考 (Pass by Reference)：函數參數使用 vector<int>& nums，加上 & 符號可以避免在呼叫函數時複製整個陣列，省下大量的時間與記憶體。
  * 大括號回傳：學會直接使用 {index1, index2} (Initializer list) 來快速回傳 vector<int>，讓程式碼更簡潔。

#### 🏆 總結 (Takeaway)
* 這題考驗的核心盲點是什麼？  ANS：直覺上會想「拿著現在的數字去後面找配對」，但這需要掃描很多次。破題關鍵是反向思考：「拿著現在的數字，回頭查歷史紀錄（Hash Map）」，看看之前有沒有人可以跟我配對。
* 下次看到類似題型，第一步該想到什麼工具？  ANS：只要題目出現「配對」、「尋找兩個數的關係」、「需要頻繁查找某個元素是否存在」，第一步就該聯想到 Hash Map / Hash Set。